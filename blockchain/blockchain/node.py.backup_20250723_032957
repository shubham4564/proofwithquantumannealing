import copy
import time
from threading import Timer

from api.main import NodeAPI
from blockchain.blockchain import Blockchain
from blockchain.p2p.message import Message, MessageType, InventoryItem, InventoryMessage, GetDataMessage
from blockchain.p2p.socket_communication import SocketCommunication
from blockchain.p2p.transaction_mempool import TransactionMempool
from blockchain.transaction.transaction_pool import TransactionPool
from blockchain.transaction.wallet import Wallet
from blockchain.utils.helpers import BlockchainUtils
from blockchain.utils.logger import logger


class Node:
    def __init__(self, ip, port, key=None):
        self.p2p = None
        self.ip = ip
        self.port = port
        
        # Legacy transaction pool for backward compatibility
        self.transaction_pool = TransactionPool()
        
        # New Bitcoin-style mempool for efficient P2P propagation
        self.mempool = TransactionMempool()
        
        self.wallet = Wallet()
        if key is not None:
            self.wallet.from_key(key)
        self.blockchain = Blockchain()
        
        # Track seen blocks to prevent rebroadcast loops
        self.seen_blocks = set()
        
        # Connection health tracking
        self.peer_health = {}  # peer_id -> last_ping_time
        self.ping_interval = 60  # Ping peers every 60 seconds

    def start_p2p(self, enhanced=True):
        """
        Start P2P communication system.
        
        Args:
            enhanced (bool): If True, use Bitcoin-style enhanced P2P with INV/GETDATA/TX.
                           If False, use legacy direct broadcast system.
        """
        if enhanced:
            logger.info("Starting enhanced Bitcoin-style P2P system")
            self.start_p2p_enhanced()
        else:
            logger.info("Starting legacy P2P system")
            self.start_p2p_legacy()
    
    def start_p2p_legacy(self):
        """Start the legacy P2P communication system (direct broadcast)"""
        self.p2p = SocketCommunication(self.ip, self.port)
        self.p2p.start_socket_communication(self)
        
        # Start periodic heartbeat to stay active in quantum consensus
        import threading
        self.heartbeat_active = True
        self.heartbeat_thread = threading.Thread(target=self._quantum_heartbeat, daemon=True)
        self.heartbeat_thread.start()
        
        logger.info("Legacy P2P system started")
        
    def _quantum_heartbeat(self):
        """Periodically update node activity in quantum consensus"""
        import time
        while self.heartbeat_active:
            try:
                # Re-register to update last_seen time (reduced frequency for CPU optimization)
                self.blockchain.quantum_consensus.register_node(
                    self.wallet.public_key_string(), 
                    self.wallet.public_key_string()
                )
                time.sleep(60)  # Reduced from 15s to 60s to lower CPU usage
            except Exception as e:
                logger.error({"message": "Heartbeat error", "error": str(e)})
                time.sleep(10)  # Increased error recovery time

    def start_node_api(self, api_port):
        self.api = NodeAPI()
        self.api.inject_node(self)
        self.api.start(self.ip, api_port)

    def handle_transaction(self, transaction, from_api=False, source_peer=None):
        """
        Handle incoming transaction with Bitcoin-style verification and propagation.
        
        Args:
            transaction: Transaction object to process
            from_api: True if transaction came from API, False if from P2P
            source_peer: Peer ID that sent the transaction (for P2P tracking)
        """
        # Register node in quantum consensus
        self.blockchain.quantum_consensus.register_node(
            self.wallet.public_key_string(), 
            self.wallet.public_key_string()
        )
        
        # 1. Verification: Check transaction legitimacy
        data = transaction.payload()
        signature = transaction.signature
        signer_public_key = transaction.sender_public_key
        signature_valid = Wallet.signature_valid(data, signature, signer_public_key)
        
        # Check for duplicates in both pools
        transaction_in_legacy_pool = self.transaction_pool.transaction_exists(transaction)
        transaction_in_blockchain = self.blockchain.transaction_exists(transaction)
        
        # Calculate transaction hash for mempool
        tx_hash = self.mempool.calculate_transaction_hash(transaction)
        transaction_in_mempool = self.mempool.has_transaction(tx_hash)

        if not signature_valid:
            logger.warning({
                "message": "Transaction rejected - invalid signature",
                "tx_hash": tx_hash[:16] + "...",
                "sender": transaction.sender_public_key[:20] + "...",
                "source": "API" if from_api else f"P2P({source_peer[:10]}...)" if source_peer else "P2P"
            })
            return

        if transaction_in_legacy_pool or transaction_in_blockchain or transaction_in_mempool:
            logger.debug({
                "message": "Transaction already known - not propagating",
                "tx_hash": tx_hash[:16] + "...",
                "in_legacy_pool": transaction_in_legacy_pool,
                "in_blockchain": transaction_in_blockchain,
                "in_mempool": transaction_in_mempool,
                "source": "API" if from_api else f"P2P({source_peer[:10]}...)" if source_peer else "P2P"
            })
            return

        # 2. Mempool Storage: Add to memory pool
        added_to_mempool = self.mempool.add_transaction(transaction, source_peer)
        
        # Also add to legacy pool for compatibility
        self.transaction_pool.add_transaction(transaction)
        
        if added_to_mempool:
            logger.info({
                "message": "Transaction verified and stored in mempool",
                "tx_hash": tx_hash[:16] + "...",
                "mempool_size": len(self.mempool.transactions),
                "legacy_pool_size": len(self.transaction_pool.transactions),
                "transaction_type": transaction.type,
                "sender": transaction.sender_public_key[:20] + "...",
                "receiver": transaction.receiver_public_key[:20] + "...",
                "source": "API" if from_api else f"P2P({source_peer[:10]}...)" if source_peer else "P2P"
            })
            
            # 3. Gossip Protocol: Propagate using INV/GETDATA pattern
            if from_api:
                # For API transactions, announce to all peers immediately
                self._announce_transaction_to_peers(tx_hash)
            else:
                # For P2P transactions, use gossip protocol with selective propagation
                self._gossip_transaction_to_peers(tx_hash, exclude_peer=source_peer)

        # Check if forging is needed
        forging_required = self.transaction_pool.forging_required()
        
        if forging_required or len(self.transaction_pool.transactions) % 10 == 0:
            logger.info({
                "message": "Checking 10-second forging interval",
                "forging_required": forging_required,
                "legacy_pool_size": len(self.transaction_pool.transactions),
                "mempool_size": len(self.mempool.transactions),
                "node_public_key": self.wallet.public_key_string()[:20] + "...",
                "source": "API" if from_api else "P2P"
            })
        
        if forging_required:
            if from_api:
                time.sleep(0.1)  # Brief delay to allow quantum consensus calculations
                
            logger.info({
                "message": "10-second interval reached, attempting quantum consensus forging",
                "source": "API" if from_api else "P2P"
            })
            self.forge()

    def handle_inventory(self, connected_node, inv_data):
        """
        Handle Bitcoin-style INV message - announcements of available transactions/blocks.
        Responds with GETDATA for items we don't have.
        """
        try:
            inv_message = InventoryMessage.from_dict(inv_data)
            peer_id = f"{connected_node.host}:{connected_node.port}"
            
            # Separate transaction and block inventories
            tx_hashes = []
            block_hashes = []
            
            for item in inv_message.inventory:
                if item.type == InventoryItem.TYPE_TX:
                    tx_hashes.append(item.hash)
                elif item.type == InventoryItem.TYPE_BLOCK:
                    block_hashes.append(item.hash)
            
            # Find missing transactions we want to request
            missing_tx_hashes = self.mempool.get_missing_transactions(tx_hashes, peer_id)
            
            # For blocks, check against our blockchain (simplified)
            missing_block_hashes = []
            for block_hash in block_hashes:
                if block_hash not in self.seen_blocks:
                    missing_block_hashes.append(block_hash)
            
            # Send GETDATA request for missing items
            if missing_tx_hashes or missing_block_hashes:
                requested_items = []
                
                for tx_hash in missing_tx_hashes:
                    requested_items.append(InventoryItem(InventoryItem.TYPE_TX, tx_hash))
                
                for block_hash in missing_block_hashes:
                    requested_items.append(InventoryItem(InventoryItem.TYPE_BLOCK, block_hash))
                
                getdata_message = GetDataMessage(requested_items)
                message = Message(self.p2p.socket_connector, MessageType.GETDATA, getdata_message.to_dict())
                encoded_message = BlockchainUtils.encode(message)
                
                self.p2p.send_to_node(connected_node, encoded_message)
                
                logger.info({
                    "message": "Requested missing items via GETDATA",
                    "peer": peer_id,
                    "requested_transactions": len(missing_tx_hashes),
                    "requested_blocks": len(missing_block_hashes),
                    "sample_tx_hashes": [h[:8] + "..." for h in missing_tx_hashes[:3]]
                })
            
        except Exception as e:
            logger.error(f"Error handling INV message from {connected_node.host}:{connected_node.port}: {e}")

    def handle_getdata(self, connected_node, getdata_data):
        """
        Handle Bitcoin-style GETDATA message - requests for specific transactions/blocks.
        Responds with TX or BLOCK_DATA messages.
        """
        try:
            getdata_message = GetDataMessage.from_dict(getdata_data)
            peer_id = f"{connected_node.host}:{connected_node.port}"
            
            served_count = 0
            
            for item in getdata_message.inventory:
                if item.type == InventoryItem.TYPE_TX:
                    # Send transaction data
                    transaction = self.mempool.get_transaction(item.hash)
                    if transaction:
                        message = Message(self.p2p.socket_connector, MessageType.TX, transaction)
                        encoded_message = BlockchainUtils.encode(message)
                        self.p2p.send_to_node(connected_node, encoded_message)
                        served_count += 1
                        
                        # Update statistics
                        self.mempool.stats['total_served'] += 1
                
                elif item.type == InventoryItem.TYPE_BLOCK:
                    # Send block data (simplified - would need block lookup by hash)
                    # For now, use the last block as a placeholder
                    if self.blockchain.blocks:
                        last_block = self.blockchain.blocks[-1]
                        message = Message(self.p2p.socket_connector, MessageType.BLOCK_DATA, last_block)
                        encoded_message = BlockchainUtils.encode(message)
                        self.p2p.send_to_node(connected_node, encoded_message)
                        served_count += 1
            
            if served_count > 0:
                logger.info({
                    "message": "Served data requests via TX/BLOCK_DATA",
                    "peer": peer_id,
                    "served_items": served_count,
                    "total_requested": len(getdata_message.inventory)
                })
                
        except Exception as e:
            logger.error(f"Error handling GETDATA message from {connected_node.host}:{connected_node.port}: {e}")

    def handle_transaction_data(self, transaction):
        """
        Handle TX message - transaction data received in response to our GETDATA request.
        """
        # Calculate peer that sent this (would need better peer tracking in production)
        source_peer = "response_peer"  # Simplified
        
        # Process the transaction normally
        self.handle_transaction(transaction, from_api=False, source_peer=source_peer)

    def handle_block_data(self, block):
        """
        Handle BLOCK_DATA message - block data received in response to our GETDATA request.
        """
        # Process the block normally
        self.handle_block(block)

    def handle_ping(self, connected_node, ping_data):
        """Handle PING message and respond with PONG"""
        try:
            # Extract nonce from ping data
            nonce = ping_data.get('nonce', int(time.time()))
            
            # Respond with PONG containing the same nonce
            pong_data = {'nonce': nonce, 'timestamp': time.time()}
            message = Message(self.p2p.socket_connector, MessageType.PONG, pong_data)
            encoded_message = BlockchainUtils.encode(message)
            self.p2p.send_to_node(connected_node, encoded_message)
            
            peer_id = f"{connected_node.host}:{connected_node.port}"
            logger.debug(f"Responded to PING from {peer_id} with PONG")
            
        except Exception as e:
            logger.error(f"Error handling PING from {connected_node.host}:{connected_node.port}: {e}")

    def handle_pong(self, connected_node, pong_data):
        """Handle PONG message - response to our PING"""
        try:
            peer_id = f"{connected_node.host}:{connected_node.port}"
            current_time = time.time()
            
            # Update peer health tracking
            self.peer_health[peer_id] = current_time
            
            # Calculate latency if we have the original ping timestamp
            if 'timestamp' in pong_data:
                ping_time = pong_data['timestamp']
                latency = current_time - ping_time
                logger.debug(f"PONG received from {peer_id}, latency: {latency*1000:.1f}ms")
            
        except Exception as e:
            logger.error(f"Error handling PONG from {connected_node.host}:{connected_node.port}: {e}")

    def start_peer_health_monitoring(self):
        """Start periodic ping to maintain connection health (Bitcoin-style)"""
        def ping_peers():
            if not self.p2p or not hasattr(self.p2p, 'all_nodes'):
                return
            
            for peer in self.p2p.all_nodes:
                try:
                    ping_data = {'nonce': int(time.time()), 'timestamp': time.time()}
                    message = Message(self.p2p.socket_connector, MessageType.PING, ping_data)
                    encoded_message = BlockchainUtils.encode(message)
                    self.p2p.send_to_node(peer, encoded_message)
                except Exception as e:
                    logger.debug(f"Failed to ping peer {peer.host}:{peer.port}: {e}")
        
        # Schedule periodic pings
        def schedule_next_ping():
            ping_peers()
            timer = Timer(self.ping_interval, schedule_next_ping)
            timer.daemon = True
            timer.start()
        
        # Start the ping cycle
        timer = Timer(self.ping_interval, schedule_next_ping)
        timer.daemon = True
        timer.start()
        
        logger.info("Started peer health monitoring with periodic pings")

    def start_p2p_enhanced(self):
        """Start the enhanced Bitcoin-style P2P communication system"""
        logger.info({
            "message": "Starting enhanced P2P system with Bitcoin-style transaction propagation",
            "node_ip": self.ip,
            "node_port": self.port,
            "features": ["INV/GETDATA/TX", "Gossip Protocol", "Peer Health Monitoring", "Transaction Mempool"]
        })
        
        # Start the standard P2P system
        self.p2p = SocketCommunication(self.ip, self.port)
        self.p2p.start_socket_communication(self)
        
        # Start enhanced features
        self.start_peer_health_monitoring()
        
        # Log initial mempool state
        logger.info({
            "message": "Enhanced P2P system initialized",
            "mempool_config": {
                "max_size": self.mempool.max_mempool_size,
                "max_peer_connections": self.mempool.max_peer_connections,
                "announcement_timeout": self.mempool.announcement_timeout
            }
        })

    def get_enhanced_node_stats(self):
        """Get comprehensive node statistics including mempool and P2P metrics"""
        base_stats = {
            "node_info": {
                "ip": self.ip,
                "port": self.port,
                "public_key_prefix": self.wallet.public_key_string()[:20] + "..."
            },
            "blockchain": {
                "total_blocks": len(self.blockchain.blocks),
                "last_block_hash": BlockchainUtils.hash(self.blockchain.blocks[-1].payload()).hex()[:16] + "..." if self.blockchain.blocks else None
            },
            "legacy_transaction_pool": {
                "size": len(self.transaction_pool.transactions)
            }
        }
        
        # Add mempool statistics
        base_stats["mempool"] = self.mempool.get_mempool_stats()
        
        # Add P2P statistics
        if self.p2p and hasattr(self.p2p, 'all_nodes'):
            base_stats["p2p"] = {
                "connected_peers": len(self.p2p.all_nodes),
                "peer_health_tracked": len(self.peer_health),
                "seen_blocks": len(self.seen_blocks)
            }
        
        return base_stats

    def _announce_transaction_to_peers(self, tx_hash):
        """
        Announce transaction using Bitcoin-style INV message to all connected peers.
        Used for transactions received via API.
        """
        if not self.p2p or not hasattr(self.p2p, 'all_nodes') or not self.p2p.all_nodes:
            return
        
        # Create inventory item for the transaction
        inv_item = InventoryItem(InventoryItem.TYPE_TX, tx_hash)
        inv_message = InventoryMessage([inv_item])
        
        # Send INV message to all connected peers
        message = Message(self.p2p.socket_connector, MessageType.INV, inv_message.to_dict())
        encoded_message = BlockchainUtils.encode(message)
        
        announced_to = 0
        for peer in self.p2p.all_nodes:
            try:
                self.p2p.send_to_node(peer, encoded_message)
                announced_to += 1
                
                # Track that we announced this transaction to this peer
                peer_id = f"{peer.host}:{peer.port}"
                self.mempool.mark_announced_to_peer(peer_id, [tx_hash])
                
            except Exception as e:
                logger.debug(f"Failed to announce transaction to peer {peer.host}:{peer.port}: {e}")
        
        logger.info({
            "message": "Transaction announced to network via INV",
            "tx_hash": tx_hash[:16] + "...",
            "announced_to_peers": announced_to,
            "total_peers": len(self.p2p.all_nodes)
        })

    def _gossip_transaction_to_peers(self, tx_hash, exclude_peer=None):
        """
        Gossip transaction to subset of peers using Bitcoin-style flood algorithm.
        Excludes the peer that sent us the transaction to prevent echo.
        """
        if not self.p2p or not hasattr(self.p2p, 'all_nodes') or not self.p2p.all_nodes:
            return
        
        # Bitcoin typically forwards to 8-10 peers, excluding the source
        max_forwards = min(8, len(self.p2p.all_nodes))
        forwarded_to = 0
        
        # Create inventory item for the transaction
        inv_item = InventoryItem(InventoryItem.TYPE_TX, tx_hash)
        inv_message = InventoryMessage([inv_item])
        message = Message(self.p2p.socket_connector, MessageType.INV, inv_message.to_dict())
        encoded_message = BlockchainUtils.encode(message)
        
        for peer in self.p2p.all_nodes:
            if forwarded_to >= max_forwards:
                break
                
            peer_id = f"{peer.host}:{peer.port}"
            
            # Skip the peer that sent us this transaction
            if exclude_peer and peer_id == exclude_peer:
                continue
            
            # Check if this peer likely already has this transaction
            if not self.mempool.get_transactions_for_announcement(peer_id):
                continue
            
            try:
                self.p2p.send_to_node(peer, encoded_message)
                self.mempool.mark_announced_to_peer(peer_id, [tx_hash])
                forwarded_to += 1
                
            except Exception as e:
                logger.debug(f"Failed to gossip transaction to peer {peer_id}: {e}")
        
        logger.info({
            "message": "Transaction gossiped to network subset",
            "tx_hash": tx_hash[:16] + "...",
            "forwarded_to_peers": forwarded_to,
            "excluded_peer": exclude_peer[:20] + "..." if exclude_peer else None
        })

    def handle_block(self, block):
        forger = block.forger
        block_hash = block.payload()
        signature = block.signature
        
        # Calculate block hash for duplicate detection
        block_hash_hex = BlockchainUtils.hash(block_hash).hex()

        logger.info({
            "message": "Received block from network",
            "block_number": block.block_count,
            "forger": forger[:30] + "..." if forger else "None",
            "transactions_count": len(block.transactions),
            "current_blockchain_length": len(self.blockchain.blocks),
            "block_hash": block_hash_hex[:16] + "..."
        })

        # Check if we've already seen this block (prevent rebroadcast loops)
        if block_hash_hex in self.seen_blocks:
            logger.info({
                "message": "Block already seen, ignoring to prevent loops",
                "block_hash": block_hash_hex[:16] + "..."
            })
            return
        
        # Mark this block as seen
        self.seen_blocks.add(block_hash_hex)
        
        # Limit seen blocks cache size to prevent memory issues
        if len(self.seen_blocks) > 1000:
            # Remove oldest 200 entries (simplified - could use LRU)
            old_blocks = list(self.seen_blocks)[:200]
            for old_block in old_blocks:
                self.seen_blocks.discard(old_block)

        # Check if we already have a block with this block_count (prevent duplicates)
        if block.block_count < len(self.blockchain.blocks):
            logger.info({
                "message": "Block already exists, ignoring",
                "block_number": block.block_count,
                "current_length": len(self.blockchain.blocks)
            })
            return

        # Fast validation path: check lightweight validations first
        # Order optimized for fail-fast: cheapest checks first
        block_count_valid = self.blockchain.block_count_valid(block)
        if not block_count_valid:
            logger.info({
                "message": "Block validation failed: invalid block count",
                "block_number": block.block_count,
                "expected": len(self.blockchain.blocks),
                "fast_reject": True
            })
            logger.info({"message": "Block count invalid, requesting full chain"})
            self.request_chain()
            return

        # Quick hash validation (relatively fast)
        last_block_hash_valid = self.blockchain.last_block_hash_valid(block)
        if not last_block_hash_valid:
            logger.info({
                "message": "Block validation failed: invalid last block hash",
                "block_number": block.block_count,
                "fast_reject": True
            })
            return

        # Expensive validations only if lightweight ones pass
        signature_valid = Wallet.signature_valid(block_hash, signature, forger)
        forger_valid = self.blockchain.forger_valid(block, signature_pre_validated=signature_valid)
        transactions_valid = self.blockchain.transactions_valid(block.transactions)

        # Enhanced logging with forger mismatch details (only if all validations performed)
        if signature_valid and forger_valid and transactions_valid:
            logger.info({
                "message": "Block validation results - all passed",
                "block_count_valid": True,
                "last_block_hash_valid": True,
                "forger_valid": True,
                "transactions_valid": True,
                "signature_valid": True,
                "optimization": "fast_path_success"
            })
        else:
            logger.info({
                "message": "Block validation results - some failed",
                "block_count_valid": True,  # Already validated above
                "last_block_hash_valid": True,  # Already validated above
                "forger_valid": forger_valid,
                "transactions_valid": transactions_valid,
                "signature_valid": signature_valid
            })

        if not block_count_valid:
            logger.info({"message": "Block count invalid, requesting full chain"})
            self.request_chain()

        # Use proper Leader-Based Consensus validation (now implemented in blockchain.py)
        # This includes the new forger validation that trusts quantum consensus selection
        if (
            last_block_hash_valid
            and forger_valid
            and transactions_valid
            and signature_valid
        ):
            logger.info({
                "message": "Block validated successfully via Leader-Based Consensus",
                "block_number": block.block_count,
                "new_blockchain_length": len(self.blockchain.blocks) + 1,
                "validations": {
                    "last_block_hash": last_block_hash_valid,
                    "forger": forger_valid,
                    "transactions": transactions_valid,
                    "signature": signature_valid
                }
            })
            self.blockchain.add_block(block)
            self.transaction_pool.remove_from_pool(block.transactions)
            
            # Rebroadcast to ensure all nodes receive the valid block
            logger.info({
                "message": "Rebroadcasting validated block to network",
                "block_number": block.block_count
            })
            message = Message(self.p2p.socket_connector, "BLOCK", block)
            self.p2p.broadcast(BlockchainUtils.encode(message))
        else:
            logger.warning({
                "message": "Block rejected due to core validation failures",
                "block_number": block.block_count,
                "forger": forger[:30] + "..." if forger else "None",
                "failed_validations": {
                    "last_block_hash": not last_block_hash_valid,
                    "transactions": not transactions_valid,
                    "signature": not signature_valid
                },
                "note": "Block rejected due to fundamental validation failures (not forger mismatch)"
            })

    def request_chain(self):
        message = Message(self.p2p.socket_connector, "BLOCKCHAINREQUEST", None)
        encoded_message = BlockchainUtils.encode(message)
        self.p2p.broadcast(encoded_message)

    def handle_blockchain_request(self, requesting_node):
        message = Message(self.p2p.socket_connector, "BLOCKCHAIN", self.blockchain)
        encoded_message = BlockchainUtils.encode(message)
        self.p2p.send(requesting_node, encoded_message)

    def handle_blockchain(self, blockchain):
        local_blockchain_copy = copy.deepcopy(self.blockchain)
        local_block_count = len(local_blockchain_copy.blocks)
        received_chain_block_count = len(blockchain.blocks)
        if local_block_count < received_chain_block_count:
            for block_number, block in enumerate(blockchain.blocks):
                if block_number >= local_block_count:
                    local_blockchain_copy.add_block(block)
                    self.transaction_pool.remove_from_pool(block.transactions)
            self.blockchain = local_blockchain_copy

    def forge(self):
        # Check if we should forge (quantum consensus selection)
        forger = self.blockchain.next_forger()
        my_public_key = self.wallet.public_key_string()
        
        logger.info({
            "message": "Forging attempt",
            "selected_forger": forger[:50] + "..." if forger else "None",
            "my_public_key": my_public_key[:50] + "...",
            "am_i_forger": forger == my_public_key,
            "transactions_in_pool": len(self.transaction_pool.transactions),
            "current_blockchain_length": len(self.blockchain.blocks)
        })
        
        if forger == my_public_key:
            try:
                # CRITICAL: Check if a block was already received for this round
                # This prevents race conditions where multiple nodes try to forge simultaneously
                expected_block_count = len(self.blockchain.blocks)
                
                logger.info({
                    "message": "I am selected as forger, proceeding with block creation",
                    "expected_block_count": expected_block_count,
                    "current_time": time.time(),
                    "transactions_available": len(self.transaction_pool.transactions)
                })
                
                # Get transactions for this block (respecting 10 MB size limit)
                max_block_size = self.blockchain.get_max_block_size()
                transactions_for_block = self.transaction_pool.get_transactions_for_block(max_block_size)
                
                # Allow forging with any number of transactions (including zero)
                # Every 10 seconds, create a block regardless of transaction count
                logger.info({
                    "message": "Creating block for 10-second interval",
                    "pool_size": len(self.transaction_pool.transactions),
                    "transactions_for_block": len(transactions_for_block),
                    "max_block_size": max_block_size
                })
                
                # Update forge time before creating block
                self.transaction_pool.update_last_forge_time()
                
                block = self.blockchain.create_block(
                    transactions_for_block, self.wallet
                )
                
                # Double-check that no block was added while we were creating this one
                if block.block_count != expected_block_count:
                    logger.warning({
                        "message": "Block race condition detected, another block was added during creation",
                        "expected_block_count": expected_block_count,
                        "actual_block_count": block.block_count,
                        "current_blockchain_length": len(self.blockchain.blocks)
                    })
                    return  # Abort forging, another node was faster
                
                logger.info({
                    "message": "Block forged successfully",
                    "block_number": block.block_count,
                    "transactions_included": len(block.transactions),
                    "forger": my_public_key[:20] + "...",
                    "block_timestamp": block.timestamp,
                    "block_hash": BlockchainUtils.hash(block.payload()).hex()[:16] + "...",
                    "remaining_in_pool": len(self.transaction_pool.transactions) - len(block.transactions)
                })
                
                # Remove only the transactions that were included in the block
                self.transaction_pool.remove_from_pool(block.transactions)
                
                # Mark our own block as seen to prevent rebroadcast loops
                forged_block_hash = BlockchainUtils.hash(block.payload()).hex()
                self.seen_blocks.add(forged_block_hash)
                
                # Broadcast the new block to all peers
                message = Message(self.p2p.socket_connector, "BLOCK", block)
                self.p2p.broadcast(BlockchainUtils.encode(message))
                
                logger.info({
                    "message": "Block broadcast to network",
                    "block_number": block.block_count,
                    "remaining_transactions": len(self.transaction_pool.transactions),
                    "peers_notified": len(self.p2p.peers)
                })
                
                # Update quantum consensus with successful proposal
                self.blockchain.quantum_consensus.record_proposal_result(my_public_key, True)
                
            except Exception as e:
                logger.error({
                    "message": "Block forging failed",
                    "error": str(e),
                    "forger": my_public_key[:20] + "..."
                })
                # Update quantum consensus with failed proposal
                self.blockchain.quantum_consensus.record_proposal_result(my_public_key, False)
                
        else:
            logger.info({
                "message": "Not selected as forger",
                "selected_forger": forger[:20] + "..." if forger else "None",
                "my_key": my_public_key[:20] + "..."
            })
